@using PokeApiNet
@using Type = PokeApiNet.Type
@using pokeAutoBuilder.Shared.Cards
@using pokeAutoBuilder.Source.Services;

@inject ProfileService ProfileService
@inject SessionService Session
@inject PokeApiService PokeApiService
@inject IDialogService DialogService
@inject ISnackbar Snackbar

<MudPaper Elevation="4" Class="d-flex flex-column align-center justify-center mud-width-full pa-2">

    @if (UseStorage)
    {
        <MudAutocomplete T="SmartPokemon" Label="Pokémon" @bind-Value="_Pokemon" SearchFunc="@SearchStorage"
                         ResetValueOnEmptyText="true" Disabled="_Locked"
                         CoerceText="true" CoerceValue="false" MaxItems="null" />
    }
    else
    {
        <MudAutocomplete T="SmartPokemonEntry" Label="Pokémon" @bind-Value="_PokemonSearchValue" SearchFunc="@SearchPokedex"
                         ResetValueOnEmptyText="true" Disabled="_Locked" MaxItems="50"
                         CoerceText="true" CoerceValue="false">
            <MoreItemsTemplate>
                <MudText Align="Align.Center" Typo="Typo.caption">
                    Only the first 50 Pokémon are shown...
                </MudText>
            </MoreItemsTemplate>
        </MudAutocomplete>
    }

    <div style="height: 50px">
        @if (_pokemonSearchValueVarieties.Count > 1)
        {
            <MudSelect Dense="true" T="string" Label="Form" AnchorOrigin="Origin.TopCenter"
                       @bind-Value="_PokemonFormName">
                @foreach (var v in _pokemonSearchValueVarieties)
                {
                    <MudSelectItem Value="@v.Name" />
                }
            </MudSelect>
        }
    </div>
    @if (_pokemon is not null)
    {
        <PokemonCard Pokemon="_pokemon" IsNameDisplayed="false" />
        @if (PokemonTeamIndex >= 0 && PokemonTeamIndex < PokemonTeam.MaxTeamSize)
        {
            <MudToggleIconButton @bind-Toggled="@_Locked"
                                 Icon="@Icons.Material.Filled.LockOpen" Color="@Color.Dark"
                                 ToggledIcon="@Icons.Material.Filled.Lock" ToggledColor="@Color.Primary" />
        }
        <MudButtonGroup Color="Color.Primary" Variant="Variant.Outlined">
            <MudTooltip Text="Details">
                <MudIconButton Size="Size.Small" Icon="@Icons.Material.Filled.OpenInFull" OnClick="OnClickDetails"></MudIconButton>
            </MudTooltip>
            <MudTooltip Text="Add To Storage">
                <MudIconButton Disabled="@(UseStorage || Globals.PokemonStorage.Contains(_pokemon))" Size="Size.Small" Icon="@Icons.Material.Filled.Save" OnClick="OnClickAddToStorage"></MudIconButton>
            </MudTooltip>
            <MudTooltip Text="Randomize">
                <MudIconButton Disabled="_Locked" Size="Size.Small" Icon="@Icons.Material.Filled.Loop" OnClick="OnClickRandomize"></MudIconButton>
            </MudTooltip>
        </MudButtonGroup>
    }
    else if (_PokemonSearchValue is not null)
    {
        if (_errorFetchingPokemon)
        {
            <MudText Typo="Typo.caption">
                Error Fetching @_PokemonSearchValue.Name
                from API
            </MudText>
        }
        else
        {
            <MudProgressCircular Color="Color.Default" Indeterminate="true" Class="mt-8 mb-8" />
        }        
    }
    else
    {
        
    }

</MudPaper>

@code {
    // if the card has a reference team it needs to know its position within the team using this index
    [Parameter]
    public int PokemonTeamIndex { get; set; } = -1;
    private int _prevPokemonTeamIndex = -1;

    // if this is true then all the pokemon options will be gathered from the storage instead of the pokedex
    [Parameter]
    public bool UseStorage { get; set; } = false;
    private bool _prevUseStorage = false;

    [Parameter]
    public EventCallback OnPokemonChanged { get; set; }

    bool _shouldRender = true;

    // currently selected pokemon
    private SmartPokemon? _pokemon;
    public SmartPokemon? _Pokemon
    {
        get => _pokemon;
        set
        {
            _pokemon = value;
        }
    }
    private SmartPokemon? _prevPokemon;

    private List<NamedApiResource<Pokemon>> _pokemonSearchValueVarieties = new();
    // the string which holds the last valid search result from the search bar
    private SmartPokemonEntry? _pokemonSearchValue;
    public SmartPokemonEntry? _PokemonSearchValue { 
        get { return _pokemonSearchValue; }
        set 
        {
            _pokemonSearchValue = value;
            _ = OnUpdatedSearchValue();
        }
    }

    // the string used in the form selector
    private string? _pokemonFormName;
    public string? _PokemonFormName
    {

        get { return _pokemonFormName; }
        set
        {
            _pokemonFormName = value;
            _ = OnUpdatedPokemonForm();
        }
    }

    // the string used in the ability selector
    private string? _pokemonAbilityName;
    public string? _PokemonAbilityName
    {

        get { return _pokemonAbilityName; }
        set
        {
            _pokemonAbilityName = value;
            OnChangeAbility(value);
        }
    }

    // only relevant if this search box is part of a team
    private bool _locked = false;
    public bool _Locked
    {
        get { return _locked; }
        set
        {
            _locked = value;
        }
    }

    private bool _errorFetchingPokemon = false;

    public void Refresh()
    {
        StateHasChanged();
    }

    // pokemon search functionality
    private async Task<IEnumerable<SmartPokemonEntry>> SearchPokedex(string value)
    {
        // if text is null or empty, show complete list
        if (string.IsNullOrEmpty(value))
            return Globals.NationalDex!;

        // search the pokedex in a background thread
        return await Task.Run(() => Globals.NationalDex!.SearchPokedex(value.ToLower()));
    }

    private async Task<IEnumerable<SmartPokemon>> SearchStorage(string value)
    {
        // if text is null or empty, show complete list
        if (string.IsNullOrEmpty(value))
            return Globals.PokemonStorage!;

        // search the storage in a background thread
        return await Task.Run(() => Globals.PokemonStorage!.Where(p => p.Name.Contains(value.ToLower())).OrderBy(p => p.Name));
    }

    public async Task OnUpdatedPokemonForm()
    {        
        // don't bother if the form name is the same as the current pokemon
        if (_PokemonFormName is null || (_Pokemon != null && _PokemonFormName == _Pokemon.Name))
            return;

        await SetPokemon(null);
        await SetPokemon(_PokemonFormName);
    }

    public async Task OnUpdatedSearchValue()
    {
        if (_PokemonSearchValue is not null)
        {
            _pokemonSearchValueVarieties = await _PokemonSearchValue.GetAllVarieties();
            await SetPokemon(_pokemonSearchValueVarieties[0].Name);
        }
        else
        {
            await SetPokemon(null);
        }
    }

    public async Task SetPokemon(string? pokemonName)
    {
        SmartPokemon? before = _pokemon;

        _errorFetchingPokemon = false;

        // clear pokemon
        if (pokemonName is null)
        {
            _pokemon = null;
        }
        else
        {
            _pokemon = await PokeApiService.GetPokemonAsync(pokemonName);
            if (_Pokemon is not null)
            {
                _pokemonFormName = _Pokemon.Name;
                _pokemonAbilityName = _Pokemon.Abilities[0].Ability.Name;
            }
            else
            {
                _errorFetchingPokemon = true;
            }
        }

        if (Session.Team is not null && PokemonTeamIndex >= 0 && PokemonTeamIndex < PokemonTeam.MaxTeamSize)
        {
            Session.Team.Pokemon[PokemonTeamIndex] = _Pokemon;
        }

        if (before != _pokemon)
        {
            _ = OnPokemonChanged.InvokeAsync();
        }

        StateHasChanged();
    }

    // pokemon ability functionality
    public void OnChangeAbility(string? value)
    {
        // SetChosenAbility uses a string to find an ability with a matching name
        if (value is not null && _pokemon is not null)
            _pokemon.SelectAbility(value);
    }

    public void OnClickAddToStorage()
    {
        if (_pokemon is null)
            return;

        Globals.PokemonStorage.Add(_pokemon);

        Snackbar.Add("Added " + _pokemon.Name + " to Pokémon Storage", Severity.Success);
    }

    public async Task OnClickDetails()
    {
        var parameters = new DialogParameters();
        parameters.Add("Pokemon", _Pokemon);

        var dialog = await DialogService.ShowAsync<PokemonDetailsDialog>(StringUtils.FirstCharToUpper(_Pokemon!.Name), parameters);
        var result = await dialog.Result;

        if (!result.Canceled && result.Data is SmartPokemon)
        {
            // replace old pokemon with updated version
            SmartPokemon? pokemon = result.Data as SmartPokemon;
            if (pokemon is not null)
            {
                int idx = Globals.PokemonStorage.IndexOf(_Pokemon!);
                if (idx >= 0)
                {
                    Globals.PokemonStorage.RemoveAt(idx);
                    Globals.PokemonStorage.Insert(idx, pokemon);
                    await ProfileService.UpdatePokemonStorageAsync();

                    this._pokemon = pokemon;                    
                }
            }
            StateHasChanged();
        }
    }

    public async Task OnClickRandomize()
    {       
        NamedApiResource<Pokemon>? pokemonResource = null;
        SmartPokemonEntry? entry = Globals.NationalDex!.RandomPokemon();
        if (entry != null)
        {
            Random rand = new Random();
            List<NamedApiResource<Pokemon>> varieties = await entry.GetAllVarieties();
            pokemonResource = varieties[rand.Next(varieties.Count)];
        }

        if (pokemonResource != null)
        {
            _pokemon = null;
            _pokemonSearchValue = entry;
            _pokemonFormName = pokemonResource.Name;
            StateHasChanged();

            SmartPokemon? pokemon = await PokeApiService.GetPokemonAsync(pokemonResource.Name);
            if (pokemon != null)
            {
                _Pokemon = pokemon;
            }
        }
    }

    protected override async Task OnInitializedAsync()
    {
        Console.WriteLine("Init PokemonSearchBox");
        // use the team index to get this pokemon if possible

    }

    protected override void OnParametersSet()
    {
        _shouldRender = PokemonTeamIndex != _prevPokemonTeamIndex ||
            UseStorage != _prevUseStorage ||
            _Pokemon != _prevPokemon;

        _prevPokemonTeamIndex = PokemonTeamIndex;
        _prevUseStorage = UseStorage;
        _prevPokemon = _Pokemon;

        if (_shouldRender && PokemonTeamIndex >= 0 && PokemonTeamIndex < PokemonTeam.MaxTeamSize)
        {
            _Pokemon = Session.Team.Pokemon[PokemonTeamIndex];
            if (_Pokemon is not null)
            {
                _pokemonSearchValue = Globals.NationalDex!.FindPokemon(_Pokemon.Species.Name);
                _pokemonFormName = _Pokemon.Name;
                _pokemonSearchValueVarieties.Clear();
                foreach (PokemonSpeciesVariety variety in _Pokemon.LoadedSpecies!.Varieties)
                {
                    _pokemonSearchValueVarieties.Add(variety.Pokemon);
                }
            }
        }

        base.OnParametersSet();
    }

    protected override bool ShouldRender()
    {
        return _shouldRender;
    }

    protected override void OnAfterRender(bool firstRender)
    {
        // TODO prevent re-rendering unnecessarily
        Console.WriteLine($"Rendered PokemonSearchBox. Index: {PokemonTeamIndex}");
    }
}
